#!/bin/bash
#Funciones genericas

function generic.info() {
    echo "generic - Funciones genéricas."
    echo
    echo "Contiene funciones genéricas de soporte para otros módulos."
}

function trim() {
    echo $*
}

function trim.info() {
    echo "generic->trim - Elimina espacios sobrantes por la izquierda y por la derecha"
    echo "                a una cadena."
    echo
    echo -e "\t Argumentos: cadena"
}

function userChoice() {

	local limite=$1
	local cadena="$2"
	local reply
	let reply=0

	echo > /dev/tty
	echo "$cadena" > /dev/tty
	read reply < /dev/tty
	echo > /dev/tty

	#We see if the user entered a number such as we need
	while [[ "$reply" -lt 0 ]] || [[ "$reply" -gt  $limite ]]; do

		#We give advice to the user and exit
		echo "Tiene que introducir un número de entre los indicados:" > /dev/tty
		read reply < /dev/tty
		#echo "Reply es: $reply" > /dev/tty

	done

	echo $reply
}

function userChoice.info() {
    echo "generic->userChoice - Da a elegir al usuario un número entre rango de 0 a n"
    echo
    echo -e "\tArgumentos:limite, cadena"
    echo
    echo "El límite establece el límite superior del rango, es decir n."
    echo "La cadena es el mensaje que se mostrará al usuario antes de introducir"
    echo "un número por teclado."
}

function callFuncion() {
	local tupla="$1"

	$DEBUG && echo "Tupla: $tupla" >> /dev/tty
	IFS=':' read -a aux <<< "$tupla"; IFS=" "
	local funcion="${aux[0]}"
	$DEBUG && echo "Función: $funcion" > /dev/tty

	local args="${aux[1]}"
	$DEBUG && echo "Argumentos: $args" > /dev/tty

	eval set -- "$args"
	$DEBUG && echo "Argumentos procesados: $@" > /dev/tty

	local postargs=""
	for arg in "$@"; do
	    postargs="$postargs \"$arg\""
	done
	postargs=$(trim "$postargs")

	$DEBUG && echo "A ejecutar: $funcion $postargs" > /dev/tty
	# local res=`$funcion "$postargs"`

	local res=`eval "$funcion" $postargs`
	echo "$res"
}


function callFuncion.info() {
    echo "generic->callFuncion - Llama a una funcion integrada de sintel"
    echo
    echo -e "\tArgumentos: tupla"
    echo
    echo "La tupla es el nombre de la función que queremos llamar y argumentos"
    echo "separados por el caracter dos puntos ':'. El argumento es opcional."
    echo
    echo "La forma más cómoda de acceder a esta función es mediante la opción"
    echo "-f de sintel".
    echo
    echo "Se puede pasar más de un argumento a una función. Para ello hay que"
    echo "entrecomillar los argumentos o toda la tupla. Si uno o varios de los"
    echo "argumentos consta de más de una palabra, es decir, que contiene"
    echo "espacios, debe entrecomillarse de por si con comilla simple o usando"
    echo "comillas dobles escapadas: \"."
    echo
    echo "Ejemplos:"
    echo -e "\tsintel -f series.list"
    echo -e "\tsintel -f series.find:poirot"
    echo -e "\tsintel -f film.add:"'Regreso al futuro' '/mnt/Peliculas/rfuturo.mp4' -1"
}

function callFuncion2() {
	local tupla="$1"

	$DEBUG && echo "Tupla: $tupla" >> /dev/tty
	IFS=':' read -a aux <<< "$tupla"; IFS=" "
	local funcion="${aux[0]}"
	$DEBUG && echo "Función: $funcion" > /dev/tty

	local args="${aux[1]}"
	$DEBUG && echo "Argumentos: $args" > /dev/tty

	declare -a preargs
	IFS='|' read -r -a preargs <<< "$args"; IFS=" "

	local postargs=""
	for arg in "${preargs[@]}"; do
		postargs="$postargs \"$arg\""
	done
	postargs=$(trim "$postargs")

	#eval set -- "$args"
	$DEBUG && echo "Argumentos procesados: $postargs" > /dev/tty

	$DEBUG && echo "A ejecutar: $funcion $postargs" > /dev/tty

	local res=`eval "$funcion" $postargs`
	echo "$res"
}

function callFuncion2.info() {
    echo "generic->callFuncion2 - Llama a una función con varios argumentos"
    echo
    echo -e "\tArgumentos: tupla-avanzada"
    echo
    echo "Tupla-avanzada consiste en 'funcion:argumento-avanzado'"
    echo "mientras que argumento avanzado es una cadena entrecomillada que admite "
    echo "varios argumentos separados por el caracter tubería '|'."
    echo
    echo "Ejemplo:"
    echo -e "\tsintel -n anime.add:\"Detective Conan|www.veranimes.tv/detective-conan-capitulo-\""
}

function listFunciones() {
    if [[ $# == 0 ]]; then
        declare -F | while read line; do
	   echo "${line:11}"
	done
    else
	declare -F | grep "$1\." | while read line; do
	   echo "${line:11}"
	done
    fi
}


function listFunciones.info() {
    echo "generic->listFunciones - Lista las funciones integradas en sintel."
    echo
    echo -e "\tArgumentos: [módulo]"
    echo
    echo "Si no se indican argumentos se listan todas las funciones definidas"
    echo "dentro de los diversos módulos de sintel."
    echo
    echo "Si se indica el nombre de un módulo se listan todas las funciones"
    echo "de ese módulo."
    echo
    echo "Si no se requiere argumento puede ahorrarse tiempo invocando el comando"
    echo "'sintel -l'. Si por el contrario se quieren ver solo las funciones de"
    echo "un módulo, podemos usar el atajo 'sintel -x anime'."
    echo
    echo "Ejemplos:"
    echo -e "\tsintel -f listFunciones"
    echo -e "\tsintel -f listFunciones:series"
}

function functionInfo() {
    local funcion="$1"

    declare -F | grep "${funcion}.info" > /dev/null 2>&1
    if [[ $? != 0 ]]; then
	echo -e "La función '$funcion' no tiene documentación de momento."
    else
	"${funcion}.info"
    fi
}


function functionInfo.info() {
    echo "generic->functionInfo - Mostrar la documentación de una función de sintel."
    echo
    echo -e "\tArgumentos: función"
    echo
    echo "La documentación de sintel está todavía escribiéndose. Puede haber funciones"
    echo "que no estén documentadas todavía."
    echo
    echo "Se puede llamar a esta función con el atajo 'sintel --info funcion'."
    echo
    echo "Ejemplos:"
    echo -e "\t sintel --info functionInfo"
    echo -e "\t sintel --info ver.serie"
}
